<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Hirpdag</title>
                <meta name="robots" content="noindex" />
                

        <!-- Custom HTML head -->
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

                <link rel="icon" href="favicon.svg">
                        <link rel="shortcut icon" href="favicon.png">
                <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
                <link rel="stylesheet" href="css/print.css" media="print">
        
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
                <link rel="stylesheet" href="fonts/fonts.css">
        
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        
            </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="ch01-00-introduction.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="ch02-00-hirpdag.html"><strong aria-hidden="true">2.</strong> Hirpdag</a></li><li class="chapter-item expanded "><a href="ch03-00-implementation.html"><strong aria-hidden="true">3.</strong> Implementation</a></li><li class="chapter-item expanded "><a href="ch04-00-techniques.html"><strong aria-hidden="true">4.</strong> Techniques</a></li></ol>            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                                                <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                                            </div>

                    <h1 class="menu-title">Hirpdag</h1>

                    <div class="right-buttons">
                                                <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                                                                        
                    </div>
                </div>

                                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p>Overview of relevant concepts.</p>
<h2 id="hashing"><a class="header" href="#hashing">Hashing</a></h2>
<p><a href="https://en.m.wikipedia.org/wiki/Hash_function">Hash Function @ Wikipedia</a></p>
<p>Producing a signature of an objects based on its contents.</p>
<h2 id="hash-consing"><a class="header" href="#hash-consing">Hash Consing</a></h2>
<p><a href="https://en.m.wikipedia.org/wiki/Hash_consing">Hash consing @ Wikipedia</a></p>
<p><a href="https://en.m.wikipedia.org/wiki/Constructor_(object-oriented_programming)">Constructor @ Wikipedia</a></p>
<p>A constructor is a function which runs automatically to setup an object.
The constructor must run to obtain a new object.</p>
<h4 id="strengths"><a class="header" href="#strengths">Strengths</a></h4>
<ul>
<li>Pointer equality</li>
<li>Saving space</li>
</ul>
<h4 id="issues"><a class="header" href="#issues">Issues</a></h4>
<ul>
<li>Overhead on construction.</li>
<li>Hash table can become large.</li>
</ul>
<h2 id="immutability"><a class="header" href="#immutability">Immutability</a></h2>
<p><a href="https://en.m.wikipedia.org/wiki/Immutable_object">Immutability @ Wikipedia</a></p>
<p><a href="https://en.m.wikipedia.org/wiki/Copy-on-write">Copy on Write @ Wikipedia</a></p>
<h4 id="strengths-1"><a class="header" href="#strengths-1">Strengths</a></h4>
<ul>
<li>Great for shared data. Multiple threads can share the same data with no synchronization issues.</li>
</ul>
<h4 id="issues-1"><a class="header" href="#issues-1">Issues</a></h4>
<ul>
<li>Requires more copy on write, which can cause copy overhead.</li>
</ul>
<h2 id="reference-counting"><a class="header" href="#reference-counting">Reference Counting</a></h2>
<p><a href="https://en.m.wikipedia.org/wiki/Reference_counting">Reference Counting @ Wikipedia</a></p>
<h4 id="strengths-2"><a class="header" href="#strengths-2">Strengths</a></h4>
<ul>
<li>Shared ownership of data.</li>
<li>Prevents use-after-free. A reference is necessary to use the data, and the data will be there as long as at least one reference exists.</li>
<li>References are cheap to pass and copy.</li>
</ul>
<h4 id="issues-2"><a class="header" href="#issues-2">Issues</a></h4>
<ul>
<li>Cannot reclaim reference cycles.</li>
<li>Overhead for incrementing/decrementing reference counts, which must be atomic because the count is shared.</li>
<li>Necessary indirection, even when the data is small. This may decrease performance by adding unprefetched random memory accesses.</li>
</ul>
<h2 id="persistent-data-structures"><a class="header" href="#persistent-data-structures">Persistent Data Structures</a></h2>
<p><a href="https://en.m.wikipedia.org/wiki/Persistent_data_structure">Persistent Data Structures @ Wikipedia</a></p>
<h4 id="strengths-3"><a class="header" href="#strengths-3">Strengths</a></h4>
<ul>
<li>Avoid storing duplicate information.</li>
<li>Can make copies and updates faster, by reducing copying of data.</li>
</ul>
<h2 id="directed-acyclic-graph"><a class="header" href="#directed-acyclic-graph">Directed Acyclic Graph</a></h2>
<p><a href="https://en.m.wikipedia.org/wiki/Directed_acyclic_graph">Directed Acyclic Graph @ Wikipedia</a></p>
<p>Directed graph is a structure composed on nodes/vertices connected by edges with a direction.</p>
<h4 id="strengths-4"><a class="header" href="#strengths-4">Strengths</a></h4>
<ul>
<li>Clearer ownership compared to a graph with cycles</li>
</ul>
<h2 id="merkle-tree"><a class="header" href="#merkle-tree">Merkle Tree</a></h2>
<p><a href="https://en.m.wikipedia.org/wiki/Merkle_tree">Merkle Tree @ Wikipedia</a></p>
<h4 id="strengths-5"><a class="header" href="#strengths-5">Strengths</a></h4>
<ul>
<li>Integrity</li>
</ul>
<h4 id="issues-3"><a class="header" href="#issues-3">Issues</a></h4>
<ul>
<li>Overhead of performing hashing and storing hashes</li>
<li>Requires data to be immutable</li>
<li>Requires more copy on write, which can cause copy overhead.</li>
</ul>
<h2 id="rewriting"><a class="header" href="#rewriting">Rewriting</a></h2>
<p><a href="https://en.m.wikipedia.org/wiki/Rewriting">Rewriting @ Wikipedia</a></p>
<p>Relevant search terms: &quot;Term rewriting&quot;, &quot;DAG rewriting&quot;, &quot;Rewrite rules&quot; (results for this one are typically overwhelmed by URL rewrite rules for web servers).</p>
<h4 id="strengths-6"><a class="header" href="#strengths-6">Strengths</a></h4>
<ul>
<li>Systematic modification of structure data</li>
</ul>
<h2 id="memoization"><a class="header" href="#memoization">Memoization</a></h2>
<p><a href="https://en.m.wikipedia.org/wiki/Memoization">Memoization @ Wikipedia</a></p>
<h4 id="strengths-7"><a class="header" href="#strengths-7">Strengths</a></h4>
<ul>
<li>Avoiding redundant work</li>
</ul>
<h4 id="issues-4"><a class="header" href="#issues-4">Issues</a></h4>
<ul>
<li>Cache invalidation problem</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="hirpdag"><a class="header" href="#hirpdag">Hirpdag</a></h1>
<p>Data structures which are:</p>
<ul>
<li><strong>H</strong>ash Consed</li>
<li><strong>I</strong>mmutable</li>
<li><strong>R</strong>eference Counted</li>
<li><strong>P</strong>ersistent</li>
<li><strong>D</strong>irected <strong>A</strong>cyclic <strong>G</strong>raph</li>
</ul>
<p>These data structures are also Merkle Trees, and amenable to DAG rewriting.</p>
<h2 id="strengths-8"><a class="header" href="#strengths-8">Strengths</a></h2>
<h4 id="time"><a class="header" href="#time">Time</a></h4>
<p>Memoization, Persistence, Incremental processing, Easy Caching (no invalidation)</p>
<h4 id="space"><a class="header" href="#space">Space</a></h4>
<p>Hash Consing can massively reduce space.</p>
<p>Repeatedly referencing the same content is a common way of creating a large amount of complexity from a small amount of source material.</p>
<h2 id="synergies"><a class="header" href="#synergies">Synergies</a></h2>
<h3 id="immutability-and-directed-acyclic-graphs"><a class="header" href="#immutability-and-directed-acyclic-graphs">Immutability and Directed Acyclic Graphs</a></h3>
<p>Immutability naturally ensures graph construction produces Directed Acyclic Graphs.
We cannot know an object's address in advance, so a mutation would be necessary to create a cycle.</p>
<h3 id="immutability-and-reference-counting"><a class="header" href="#immutability-and-reference-counting">Immutability and Reference Counting</a></h3>
<p>One of the weaknesses of reference counting is that it cannot reclaim reference cycles.
Immutability makes it impossible to construct a reference cycle, which prevents this issue.</p>
<h3 id="immutability-and-memoization"><a class="header" href="#immutability-and-memoization">Immutability and Memoization</a></h3>
<p>One of the weaknesses of Memoization is cache invalidation.
Data which is immutable and referentially transparent (no semantic variation with context) avoids the problem of cache invalidation.
Information of cached relations typically remains valid.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="implementation"><a class="header" href="#implementation">Implementation</a></h1>
<h2 id="hashing-1"><a class="header" href="#hashing-1">Hashing</a></h2>
<p>Want stable hashing.
Do not hash on pointer values.</p>
<h2 id="hashconsing"><a class="header" href="#hashconsing">Hashconsing</a></h2>
<h3 id="weak-references"><a class="header" href="#weak-references">Weak references</a></h3>
<h4 id="intrusive-counters-with-weak-count"><a class="header" href="#intrusive-counters-with-weak-count">Intrusive counters with weak count</a></h4>
<p>Reference counts in same allocation as data. When strong ref count hits zero, destroy the data.
Until the weak ref count hits zero, the object remains to indicate that there is zero strong refs so weak refs cannot access data.</p>
<p>Consider adding indirection to the data if the data is large and weak pointers may survive a long time.</p>
<p>Good catch coherency, fewer allocations.</p>
<h4 id="separate-counters-with-weak-count"><a class="header" href="#separate-counters-with-weak-count">Separate counters with weak count</a></h4>
<p>Reference counts in a separate allocation to the data. When strong ref count hits zero the allocation for the data can be freed.
The allocation for the counts remains to indicate the pointer is now invalid until the weak ref count also hits zero.</p>
<p>Reference objects have two pointers, one to the counters and one to the object. Strong refs can access the data pointer directly.
Weak refs must access the counters first and check strong is nonzero to upgrade.</p>
<p>Less cache coherency, more allocations.</p>
<h4 id="weak-reference-with-intrusive-linked-list"><a class="header" href="#weak-reference-with-intrusive-linked-list">Weak reference with intrusive linked list</a></h4>
<p>All weak refs to an object form an intrusive linked list. The head of the linked list is stored with the reference counts.
As part of deleting an object, traverse all the weak references to that object via the intrusive linked list and set them to null.</p>
<h3 id="reference-counting-optimizations"><a class="header" href="#reference-counting-optimizations">Reference Counting Optimizations</a></h3>
<h4 id="cache-invalidation-and-immutability"><a class="header" href="#cache-invalidation-and-immutability">Cache Invalidation and Immutability</a></h4>
<p>Updating a reference count will <a href="https://dl.acm.org/doi/10.1145/185009.185016">modify a cache line</a> containing an object.
One of the strengths of immutable data, such as objects in Hirpdag, is that it can be shared between threads.
Modifying reference counts adjacent to objects will dirty unmodified shared cache lines.</p>
<p>Unmodified cache lines can remain in the <a href="https://en.m.wikipedia.org/wiki/MESI_protocol">Shared state</a></p>
<h4 id="coalescing-and-elision"><a class="header" href="#coalescing-and-elision">Coalescing and Elision</a></h4>
<p>Coalescing reference count modifications together can reduce update operations by <a href="https://dl.acm.org/doi/10.1145/2426642.2259008">50-90%</a>.
Only the first increment and last decrement need to remain in the same place.
This kind of statement reodering and combining would need compiler support to be
<a href="https://www.microsoft.com/en-us/research/uploads/prod/2020/11/perceus-tr-v1.pdf">applied comprehensively</a>.</p>
<h2 id="comparisons"><a class="header" href="#comparisons">Comparisons</a></h2>
<h3 id="pointer-equality"><a class="header" href="#pointer-equality">Pointer Equality</a></h3>
<p>Compare object pointers for equality or inequality.</p>
<h3 id="ordering"><a class="header" href="#ordering">Ordering</a></h3>
<p>Cannot use the object pointers for ordering in many contexts, they are unstable and meaningless.</p>
<p>A deterministic ordering is desirable, which reflects a partial order of the global Hirpdag object DAG.</p>
<h2 id="normalization"><a class="header" href="#normalization">Normalization</a></h2>
<p>On construction.</p>
<h2 id="rewriting-1"><a class="header" href="#rewriting-1">Rewriting</a></h2>
<p>Apply rewrite rule to self.
Rewrite all children.
Construct a replacement for self, if anything changed.</p>
<h2 id="memoization-1"><a class="header" href="#memoization-1">Memoization</a></h2>
<p>Enabled by immutability and reference counting.</p>
<p>Hash map of reference to reference. Key is input, value is output.</p>
<h2 id="serialization"><a class="header" href="#serialization">Serialization</a></h2>
<p>Leaf objects should appear before other objects which use them.
The serialization ordering should be a valid bottom up partial order.
A post-order traversal will produce one possible linear ordering.</p>
<p>Good to mark reference handle roots in serialization format.</p>
<h2 id="cache-coherent-datastructures"><a class="header" href="#cache-coherent-datastructures">Cache coherent datastructures</a></h2>
<p>Immutable data will typically make non-contiguous data structures (such as tree-sets, tree-maps, and linked-lists) less appealing.</p>
<p>Cache line size is typically 64 bytes on most modern x86 systems.</p>
<pre><code class="language-shell">$ getconf LEVEL1_DCACHE_LINESIZE
64
</code></pre>
<h2 id="object-metadata"><a class="header" href="#object-metadata">Object Metadata</a></h2>
<p>Each Hirpdag Object has a small amount of metadata attached to it. This includes:</p>
<ul>
<li>DAG Height</li>
<li>DAG Count</li>
<li>Content flags</li>
</ul>
<p>The content flags are intended to provide a hint to avoid unnecessary traversals.</p>
<h2 id="reference-count-update-elision"><a class="header" href="#reference-count-update-elision">Reference Count Update Elision</a></h2>
<p>Incrementing and decrementing can be expensive and they may occur frequently. Because the count is shared so these updates must be atomic.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="techniques"><a class="header" href="#techniques">Techniques</a></h1>
<p>Techniques for using Hirpdag to maximize effectiveness.</p>
<h2 id="referential-transparency"><a class="header" href="#referential-transparency">Referential Transparency</a></h2>
<p><a href="https://en.m.wikipedia.org/wiki/Referential_transparency">Referential Transparency @ Wikipedia</a></p>
<p>Hirpdag objects should generally be designed to have referential transparency.</p>
<p>Objects which are identical should not have different meanings in a different context/environment.</p>
<h2 id="common-normalization"><a class="header" href="#common-normalization">Common Normalization</a></h2>
<p>Hirpdag objects should apply normalization to increase the effectiveness of hashconsing.</p>
<p>Normalization is important for pointer inequality to correspond with semantic inequality.
Fast pointer equality based comparisons is one of the key features hash consing provides.
Without good normalization, deeper comparisons are needed and the pointer equality benefit of hashconsing is lost.</p>
<h3 id="order-normalization"><a class="header" href="#order-normalization">Order Normalization</a></h3>
<p><code>y+x</code>
<code>x+y</code></p>
<p>Sort commutative operands. Prefer flatter expression trees to make this easier.</p>
<h3 id="semantic-normalization"><a class="header" href="#semantic-normalization">Semantic Normalization</a></h3>
<p><code>x+x</code>
<code>2*x</code></p>
<h2 id="structuring-for-persistence-and-normalization"><a class="header" href="#structuring-for-persistence-and-normalization">Structuring for Persistence and Normalization</a></h2>
<p>The structure of Hirpdag objects can have a big impact on the effectiveness of normalization and persistence.</p>
<h3 id="prefer-flatter-structures"><a class="header" href="#prefer-flatter-structures">Prefer Flatter Structures</a></h3>
<p>Consider:</p>
<ul>
<li><code>A=a+b+d+e</code></li>
</ul>
<p>As a binary tree (before normalization) it might look like:</p>
<ul>
<li><code>a=b=sum(a, sum(b, sum(d, e)))</code></li>
<li><code>a=b=sum(sum(a, b), sum(d, e))</code></li>
<li><code>a=b=sum(sum(sum(a, b), d), e)</code></li>
</ul>
<p>With a binary tree representation, the first question is: which of these semantically equivalent structures is the normalized form?</p>
<p>Consider:</p>
<ul>
<li><code>B=a+d+b+e</code></li>
</ul>
<p>As a binary tree (before normalization) it might look like:</p>
<ul>
<li><code>B=Sum(Sum(a, d), Sum(b, e))</code></li>
</ul>
<p><code>B</code> is semantically equivalent to <code>A</code>, and should normalize to the same thing.
In this case, the order of the operands needs to change.</p>
<p>With a binary tree representation, the second question is: what is necessary to normalized the operand order?
Traversing the existing tree is necessary to gather these operands for sorting.
Performance wise, this is similar to traversing a linked list (i.e: bad).</p>
<p>As a n-ary tree:
A=Sum(a, b, d, e)</p>
<p>More contiguous. Easier to sort. Easier to traverse. Easier to construct. Easier to normalize (just sort).</p>
<p>When used as a persistent data structure, this means changing one n-ary Sum object rather than several binary Sum objects.</p>
<p>In general, if a Hirpdag object can refer to other Hirpdag objects of the same type and ordering is not important,
this suggests you should consider changing their structure to combine them into one flattened Hirpdag object.</p>
<h3 id="not-too-big-not-too-small"><a class="header" href="#not-too-big-not-too-small">Not too big, not too small</a></h3>
<p>If a Hirpdag object has too much information, deduplication opportunities will be unlikely.</p>
<p>If a Hirpdag object has too little information, encoding a useful piece of information will require many objects.
This will have a negative impact on performance due to:</p>
<ul>
<li>Worse memory access patterns chasing pointers (like a linked list).</li>
<li>More time spent allocating/deallocating.</li>
</ul>
<p>Consider which fields may be large (e.g. a vector field may grow large).
Consider which fields will need to mutate together.</p>
<h3 id="encoding-graphs"><a class="header" href="#encoding-graphs">Encoding Graphs</a></h3>
<p>If the graph to store is acyclic, it could be directly constructed.</p>
<p>If the nodes or edges carry some information, they should likely be separate nodes.
This makes the graph better for persistence.</p>
<p>An <a href="https://en.m.wikipedia.org/wiki/Adjacency_list">adjacency list</a> or <a href="https://en.m.wikipedia.org/wiki/Edge_list">edge list</a> can encode the graph structure itself.</p>
<pre><code>type NodeIndex = u32;

struct Node {
  name: String,
}

struct Graph {
  nodes: Vec&lt;Node&gt;,
  edges: Vec&lt;(NodeIndex, NodeIndex)&gt;, // Sorted
}
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                        
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                            </nav>

        </div>

        
        
        
                <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        
        
                <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        
                        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
                
    </body>
</html>
